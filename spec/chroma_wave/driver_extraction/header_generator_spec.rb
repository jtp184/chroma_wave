# frozen_string_literal: true

require_relative '../../../lib/chroma_wave/driver_extraction'

RSpec.describe ChromaWave::DriverExtraction::HeaderGenerator do
  subject(:output) { described_class.new([config]).generate }

  let(:opcodes) { ChromaWave::DriverExtraction::Opcodes }
  let(:default_init) { [0x01, 2, 0x03, 0x00, opcodes::SEQ_WAIT_BUSY, opcodes::SEQ_END] }

  let(:config) do
    ChromaWave::DriverExtraction::DriverConfig.new(
      model_name: model_name, width: width, height: height,
      pixel_format: pixel_format, busy_polarity: :active_high,
      reset_ms: [20, 2, 20], display_cmd: 0x24, display_cmd_two: 0x00,
      sleep_cmd: 0x10, sleep_data: 0x01, capabilities: capabilities,
      init_sequence: init_sequence, init_fast_sequence: init_fast_sequence,
      init_partial_sequence: init_partial_sequence,
      tier2_reason: tier2_reason, warnings: []
    )
  end

  let(:model_name) { 'EPD_test' }
  let(:width) { 200 }
  let(:height) { 200 }
  let(:pixel_format) { :mono }
  let(:capabilities) { Set.new }
  let(:init_sequence) { default_init }
  let(:init_fast_sequence) { nil }
  let(:init_partial_sequence) { nil }
  let(:tier2_reason) { nil }

  describe '#generate' do
    it 'includes the ifndef open guard' do
      expect(output).to include('#ifndef DRIVER_CONFIGS_GENERATED_H')
    end

    it 'includes the ifndef define guard' do
      expect(output).to include('#define DRIVER_CONFIGS_GENERATED_H')
    end

    it 'includes the endif guard' do
      expect(output).to include('#endif /* DRIVER_CONFIGS_GENERATED_H */')
    end

    it 'includes the auto-generated comment' do
      expect(output).to include('AUTO-GENERATED by')
    end

    it 'includes the model count summary' do
      expect(output).to include('Models: 1 total, 0 tier2')
    end

    it 'includes chroma_wave.h header' do
      expect(output).to include('#include "chroma_wave.h"')
    end

    it 'includes driver_registry.h header' do
      expect(output).to include('#include "driver_registry.h"')
    end

    it 'includes the EPD_MODEL_COUNT macro' do
      expect(output).to include('#define EPD_MODEL_COUNT')
    end

    it 'declares the init array' do
      expect(output).to include('static const uint8_t epd_test_init[] = {')
    end

    it 'includes the config table' do
      expect(output).to include('static const epd_model_config_t epd_model_configs[] = {')
    end

    it 'includes the model name in the table' do
      expect(output).to include('.name = "epd_test"')
    end

    it 'includes width' do
      expect(output).to include('.width = 200')
    end

    it 'includes height' do
      expect(output).to include('.height = 200')
    end

    it 'includes pixel format' do
      expect(output).to include('.pixel_format = PIXEL_FORMAT_MONO')
    end

    it 'includes busy polarity' do
      expect(output).to include('.busy_polarity = BUSY_ACTIVE_HIGH')
    end

    it 'includes reset timing' do
      expect(output).to include('.reset_ms = {20, 2, 20}')
    end

    it 'includes display command' do
      expect(output).to include('.display_cmd = 0x24')
    end

    it 'includes sleep_cmd' do
      expect(output).to include('.sleep_cmd = 0x10')
    end

    it 'includes sleep_data' do
      expect(output).to include('.sleep_data = 0x01')
    end

    context 'with tier2 config' do
      let(:tier2_reason) { 'Complex LUT loading' }

      it 'includes tier2 count in summary' do
        expect(output).to include('Models: 1 total, 1 tier2')
      end

      it 'includes tier2 comment on init array' do
        expect(output).to include('/* TIER2: Complex LUT loading */')
      end
    end

    context 'with capabilities' do
      let(:capabilities) { Set[:fast, :partial] }

      it 'includes capability flags' do
        expect(output).to include('EPD_CAP_PARTIAL | EPD_CAP_FAST')
      end
    end

    context 'with fast and partial sequences' do
      let(:init_fast_sequence) { [0x01, 1, 0x80, opcodes::SEQ_END] }
      let(:init_partial_sequence) { [0x01, 1, 0x40, opcodes::SEQ_END] }

      it 'declares the fast init array' do
        expect(output).to include('static const uint8_t epd_test_init_fast[] = {')
      end

      it 'declares the partial init array' do
        expect(output).to include('static const uint8_t epd_test_init_partial[] = {')
      end

      it 'references fast array in config table' do
        expect(output).to include('.init_fast_sequence = epd_test_init_fast')
      end

      it 'references partial array in config table' do
        expect(output).to include('.init_partial_sequence = epd_test_init_partial')
      end
    end

    context 'with nil init sequence' do
      let(:init_sequence) { nil }

      it 'uses NULL for init_sequence' do
        expect(output).to include('.init_sequence = NULL')
      end

      it 'uses 0 for init_sequence_len' do
        expect(output).to include('.init_sequence_len = 0')
      end
    end
  end

  describe '#generate with multiple configs' do
    subject(:output) { described_class.new(configs).generate }

    let(:config_first) do
      ChromaWave::DriverExtraction::DriverConfig.new(
        model_name: 'EPD_first', width: 200, height: 200,
        pixel_format: :mono, busy_polarity: :active_high,
        reset_ms: [20, 2, 20], display_cmd: 0x24, display_cmd_two: 0x00,
        sleep_cmd: 0x10, sleep_data: 0x01, capabilities: Set.new,
        init_sequence: default_init, init_fast_sequence: nil,
        init_partial_sequence: nil, tier2_reason: nil, warnings: []
      )
    end

    let(:config_second) do
      ChromaWave::DriverExtraction::DriverConfig.new(
        model_name: 'EPD_second', width: 200, height: 200,
        pixel_format: :mono, busy_polarity: :active_high,
        reset_ms: [20, 2, 20], display_cmd: 0x24, display_cmd_two: 0x00,
        sleep_cmd: 0x10, sleep_data: 0x01, capabilities: Set.new,
        init_sequence: default_init, init_fast_sequence: nil,
        init_partial_sequence: nil, tier2_reason: nil, warnings: []
      )
    end

    let(:configs) { [config_first, config_second] }

    it 'includes the first model' do
      expect(output).to include('.name = "epd_first"')
    end

    it 'includes the second model' do
      expect(output).to include('.name = "epd_second"')
    end

    it 'reports correct total' do
      expect(output).to include('Models: 2 total')
    end

    it 'places comma after non-last entry' do
      expect(output).to match(/\.sleep_data = 0x01\n    },\n/)
    end

    it 'omits comma after last entry' do
      expect(output).to match(/\.sleep_data = 0x01\n    }\n};/)
    end
  end

  describe 'format_init_sequence determinism' do
    it 'formats SEQ_HW_RESET by name' do
      expect(output).to include('SEQ_END,')
    end

    context 'with sentinel sequence' do
      let(:init_sequence) do
        [opcodes::SEQ_HW_RESET, opcodes::SEQ_WAIT_BUSY, 0x01, 1, 0x03, opcodes::SEQ_END]
      end

      it 'formats HW_RESET sentinel' do
        expect(output).to include('SEQ_HW_RESET,')
      end

      it 'formats WAIT_BUSY sentinel' do
        expect(output).to include('SEQ_WAIT_BUSY,')
      end
    end

    context 'with delay sequence' do
      let(:init_sequence) { [opcodes::SEQ_DELAY_MS, 100, opcodes::SEQ_END] }

      it 'formats delay with value' do
        expect(output).to include('SEQ_DELAY_MS, 100,')
      end
    end

    context 'with command data bytes' do
      let(:init_sequence) { [0x44, 2, 0x00, 0x0F, opcodes::SEQ_END] }

      it 'formats command with hex data bytes' do
        expect(output).to include('0x44, 2, 0x00, 0x0F,')
      end
    end
  end
end
