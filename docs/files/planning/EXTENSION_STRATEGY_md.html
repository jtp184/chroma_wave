<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>EXTENSION_STRATEGY.md</title>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>EXTENSION_STRATEGY.md
</h1>
<div class='paths'>
planning/EXTENSION_STRATEGY.md
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<span id="label-ChromaWave+C+Extension+Strategy" class="legacy-anchor"></span>
<h1 id="chromawave-c-extension-strategy"><a href="#chromawave-c-extension-strategy"><a href="../../classes/ChromaWave.html"><code>ChromaWave</code></a> C Extension Strategy</a></h1>

<p>Design decisions and architecture for the Ruby C extension that wraps the Waveshare vendor library. For documentation of the vendor library itself, see <a href="WAVESHARE_LIBRARY_md.html">WAVESHARE_LIBRARY.md</a>.</p>

<p><strong>Companion documents:</strong> - <a href="API_REFERENCE_md.html">API_REFERENCE.md</a> â€” Full code contracts for all classes and C structs - <a href="CONTENT_PIPELINE_md.html">CONTENT_PIPELINE.md</a> â€” Color, drawing, text, icons, and image loading - <a href="ROADMAP_md.html">ROADMAP.md</a> â€” Phased task breakdown with subtasks and acceptance criteria - <a href="MOCKING_md.html">MOCKING.md</a> â€” Mock hardware strategy for development and testing</p>
<hr>

<span id="label-1.+Vendor+Component+Assessment" class="legacy-anchor"></span>
<h2 id="1-vendor-component-assessment"><a href="#1-vendor-component-assessment">1. Vendor Component Assessment</a></h2>

<p>What we use from the vendor library and how:</p>

<table role="table">
<thead>
<tr>
<th>Component</th>
<th>Usable?</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEV_Config HAL</td>
<td>Yes</td>
<td>Thin, well-defined interface. Include as-is.</td>
</tr>
<tr>
<td>EPD_*.c drivers</td>
<td>Partial</td>
<td>Init register sequences and LUT tables are essential.</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Boilerplate (Reset, SendCommand, SendData, ReadBusy)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>is duplicated across all 70 files and should be factored</td>
</tr>
<tr>
<td></td>
<td></td>
<td>into shared helpers owned by the Device layer.</td>
</tr>
<tr>
<td>GUI_Paint</td>
<td>Minimal</td>
<td>Only the pixel-packing logic in <code>Paint_SetPixel</code> and</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>Paint_Clear</code> (~100 lines). Drawing primitives (line,</td>
</tr>
<tr>
<td></td>
<td></td>
<td>rect, circle, text) are pure algorithms that belong in</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Ruby. See Section 2.1 for rationale.</td>
</tr>
<tr>
<td>GUI_BMPfile</td>
<td>No</td>
<td>File I/O should be handled in Ruby, not C.</td>
</tr>
<tr>
<td>Fonts</td>
<td>No</td>
<td>Hard-coded bitmaps. Replace with FreeType or similar.</td>
</tr>
<tr>
<td>Debug.h</td>
<td>Yes</td>
<td>Redirect to Ruby <code>rb_warn()</code> instead of <code>printf</code>.</td>
</tr>
</tbody>
</table>

<span id="label-1.1+What+We+Must+Replace" class="legacy-anchor"></span>
<h3 id="11-what-we-must-replace"><a href="#11-what-we-must-replace">1.1 What We Must Replace</a></h3>
<ul><li>
<p><strong>Global PAINT state</strong> â€“ the <code>PAINT Paint</code> global conflates pixel storage, coordinate transforms, and drawing context. Replace with a C-backed <code>Framebuffer</code> struct (owns buffer</p>
</li><li>
<p>pixel format metadata) wrapped via <code>TypedData_Wrap_Struct</code>. Coordinate transforms and drawing move to Ruby entirely (see Section 2).</p>
</li><li>
<p><strong>printf-based debug</strong> â€“ redirect <code>Debug()</code> macro to <code>rb_warn()</code> or a configurable logger.</p>
</li><li>
<p><strong>DEV_Module_Init / Exit</strong> â€“ wrap in a Ruby <code>ChromaWave::Device</code> lifecycle object with proper <code>dfree</code> cleanup. Supports both block-style (<code>Display.open { |d| ... }</code>) and explicit <code>close</code> for long-lived instances.</p>
</li><li>
<p><strong>malloc for image buffers</strong> â€“ allocate via <code>xmalloc</code> / <code>xfree</code> (Rubyâ€™s tracked allocator) so Rubyâ€™s GC tracks the memory pressure.</p>
</li><li>
<p><strong>Duplicated I/O primitives</strong> â€“ <code>Reset()</code>, <code>SendCommand()</code>, <code>SendData()</code>, <code>ReadBusy()</code> are copy-pasted identically across all 70 driver files (~1,400 lines of duplication). These belong on the Device layer as shared functions, parameterized by busy polarity and reset timing.</p>
</li></ul>

<span id="label-1.2+What+We+Must+Abstract" class="legacy-anchor"></span>
<h3 id="12-what-we-must-abstract"><a href="#12-what-we-must-abstract">1.2 What We Must Abstract</a></h3>
<ul><li>
<p><strong>Model selection</strong> â€“ the vendor library is compile-time-selected. We compile all drivers and select at runtime via a two-tier registry (config data + optional code overrides). Total code size of all 70 drivers is modest (~500KB compiled). See Section 3.5.</p>
</li><li>
<p><strong>Platform selection</strong> â€“ similarly compile-time. For the gem, we should:</p>
</li><li>
<p>Default to <code>USE_LGPIO_LIB</code> for RPi 5 / modern Raspberry Pi OS</p>
</li><li>
<p>Allow <code>USE_DEV_LIB</code> as fallback (gpiod, most portable)</p>
</li><li>
<p>Detect platform in <a href="../ext/chroma_wave/extconf_rb.html">extconf.rb</a> and set appropriate <code>-D</code> flags</p>
</li><li>
<p>Define a <code>MOCK</code> backend for development/testing on non-RPi systems</p>
</li></ul>

<span id="label-1.3+What+We+Should+NOT+Use" class="legacy-anchor"></span>
<h3 id="13-what-we-should-not-use"><a href="#13-what-we-should-not-use">1.3 What We Should NOT Use</a></h3>
<ul><li>
<p><strong>GUI_Paint.c drawing primitives</strong> â€“ <code>Paint_DrawLine</code>, <code>Paint_DrawRectangle</code>, <code>Paint_DrawCircle</code>, <code>Paint_DrawChar</code>, <code>Paint_DrawString_*</code>, <code>Paint_DrawNum</code>, etc. These are pure Bresenham/rasterization algorithms (~750 lines) that are better implemented in Ruby for extensibility, testability, and ecosystem integration. Only the pixel-packing core (<code>Paint_SetPixel</code> + <code>Paint_Clear</code>, ~100 lines) is extracted into <a href="../ext/chroma_wave/framebuffer_c.html">framebuffer.c</a>.</p>
</li><li>
<p><strong>GUI_BMPfile.c</strong> â€“ BMP loading should happen in Ruby (ChunkyPNG, MiniMagick, or Vips). The C BMP loader is limited to 24-bit uncompressed BMP only.</p>
</li><li>
<p><strong>Font bitmap tables</strong> â€“ The built-in fonts are tiny (5x8 to 17x24) fixed-width bitmaps with only ASCII + limited GB2312. Replace with FreeType or Ruby-side text rendering.</p>
</li><li>
<p><strong>Driver boilerplate</strong> â€“ The <code>Reset()</code>, <code>SendCommand()</code>, <code>SendData()</code>, <code>ReadBusy()</code> static functions duplicated across all 70 driver files. These are factored into shared Device-level functions parameterized by model config.</p>
</li><li>
<p><strong>examples/</strong> â€“ Test programs are useful as reference but should not be compiled into the gem.</p>
</li><li>
<p><strong>Makefile</strong> â€“ Weâ€™ll use <a href="../ext/chroma_wave/extconf_rb.html">extconf.rb</a> + <code>mkmf</code> instead.</p>
</li></ul>
<hr>

<span id="label-2.+Responsibility+Split-3A+Ruby+vs+C" class="legacy-anchor"></span>
<h2 id="2-responsibility-split-ruby-vs-c"><a href="#2-responsibility-split-ruby-vs-c">2. Responsibility Split: Ruby vs C</a></h2>

<p>A critical design decision is where to draw the line between C and Ruby. The guiding principle: <strong>C handles hardware I/O and bit-level buffer manipulation. Ruby handles everything else.</strong></p>

<span id="label-2.1+Why+Drawing+Belongs+in+Ruby" class="legacy-anchor"></span>
<h3 id="21-why-drawing-belongs-in-ruby"><a href="#21-why-drawing-belongs-in-ruby">2.1 Why Drawing Belongs in Ruby</a></h3>

<p>The vendorâ€™s <code>GUI_Paint.c</code> has two distinct responsibilities:</p>
<ol><li>
<p><strong>Pixel packing</strong> (<code>Paint_SetPixel</code>, <code>Paint_Clear</code>) â€“ Scale-dependent bit-twiddling that packs color values into byte buffers using format-specific layouts (1-bit MSB bitmask, 2-bit pairs, 4-bit nibbles). This is ~100 lines of C and genuinely benefits from being in C.</p>
</li><li>
<p><strong>Drawing algorithms</strong> (<code>Paint_DrawLine</code>, <code>Paint_DrawRectangle</code>, <code>Paint_DrawCircle</code>, <code>Paint_DrawChar</code>, etc.) â€“ Pure Bresenham/rasterization algorithms that call <code>SetPixel</code> in loops. These are ~750 lines of C that:</p>
</li><li>
<p>Have no hardware interaction</p>
</li><li>
<p>Are limited (no anti-aliasing, no alpha, no clipping, no real font support)</p>
</li><li>
<p>Duplicate what Ruby drawing libraries already do better</p>
</li><li>
<p>Are trivial to implement in Ruby (Bresenham is ~20 lines)</p>
</li></ol>

<p>For e-paper displays, refresh takes 2-15 seconds. Drawing overhead is irrelevant. Even the worst case (filling every pixel on an 800x480 display = ~384K Ruby-&gt;C FFI calls for <code>set_pixel</code>) completes well under a second.</p>

<p><strong>By keeping drawing in Ruby, we gain:</strong> - Extensibility (anti-aliasing, compositing, alpha) without touching C - Testability (no hardware needed to test drawing logic) - Ecosystem integration (ChunkyPNG, Vips, FreeType interop at the Ruby level) - No need to fork/maintain a modified GUI_Paint.c</p>

<span id="label-2.2+Responsibility+Matrix" class="legacy-anchor"></span>
<h3 id="22-responsibility-matrix"><a href="#22-responsibility-matrix">2.2 Responsibility Matrix</a></h3>

<table role="table">
<thead>
<tr>
<th>Concern</th>
<th>Layer</th>
<th>Rationale</th>
</tr>
</thead>
<tbody>
<tr>
<td>GPIO/SPI lifecycle</td>
<td>C</td>
<td>Hardware handles, platform-specific</td>
</tr>
<tr>
<td>SPI command/data protocol</td>
<td>C</td>
<td>Bit-level timing, CS/DC pin toggling</td>
</tr>
<tr>
<td>Display init/sleep/refresh</td>
<td>C</td>
<td>Register sequences, busy-wait, GVL release</td>
</tr>
<tr>
<td>Pixel packing into buffer</td>
<td>C</td>
<td>Bit-twiddling (MSB bitmask, nibble packing)</td>
</tr>
<tr>
<td>Buffer allocation/free</td>
<td>C</td>
<td><code>xmalloc</code>/<code>xfree</code> with <code>TypedData</code> lifecycle</td>
</tr>
<tr>
<td>Bulk buffer clear/fill</td>
<td>C</td>
<td>Format-aware memset, faster than per-pixel</td>
</tr>
<tr>
<td>Canvas bulk ops</td>
<td>C*</td>
<td>clear, blit_alpha, load_rgba (~80 lines)</td>
</tr>
<tr>
<td>Coordinate transforms</td>
<td>Ruby</td>
<td>Rotation/mirror matrix math, no hardware</td>
</tr>
<tr>
<td>Surface protocol</td>
<td>Ruby</td>
<td>Abstract drawing target (duck-type interface)</td>
</tr>
<tr>
<td>Canvas (RGBA buffer)</td>
<td>Ruby</td>
<td>Packed String storage, Ruby API, C hot paths</td>
</tr>
<tr>
<td>Layer composition</td>
<td>Ruby</td>
<td>Clip regions, offset blitting, widget bounds</td>
</tr>
<tr>
<td>Drawing primitives</td>
<td>Ruby</td>
<td>Bresenham algorithms, calls <code>Surface#set_pixel</code></td>
</tr>
<tr>
<td>Rendering / quantization</td>
<td>Ruby</td>
<td>RGBAâ†’palette mapping, dithering, dual-buf split</td>
</tr>
<tr>
<td>Text rendering</td>
<td>Ruby</td>
<td>FreeType or pre-rendered, not bitmap fonts</td>
</tr>
<tr>
<td>Image loading/conversion</td>
<td>Ruby</td>
<td>ruby-vips, bulk load into Canvas via load_rgba</td>
</tr>
<tr>
<td>Display capability queries</td>
<td>Ruby</td>
<td><code>respond_to?</code> / module inclusion checks</td>
</tr>
<tr>
<td>Model configuration</td>
<td>Ruby</td>
<td>Resolution, format, capabilities per model</td>
</tr>
</tbody>
</table>

<blockquote>
<p><strong>C*:</strong> Canvas C accelerators are optional. All three methods have Ruby fallbacks. The C code operates on Canvasâ€™s Ruby String buffer (<code>RSTRING_PTR</code>), not its own allocation â€” Canvas owns its data, C just processes it faster.</p>
</blockquote>
<hr>

<span id="label-3.+Architecture" class="legacy-anchor"></span>
<h2 id="3-architecture"><a href="#3-architecture">3. Architecture</a></h2>

<span id="label-3.1+The+PixelFormat+Unifying+Concept" class="legacy-anchor"></span>
<h3 id="31-the-pixelformat-unifying-concept"><a href="#31-the-pixelformat-unifying-concept">3.1 The <code>PixelFormat</code> Unifying Concept</a></h3>

<p>The vendor libraryâ€™s <code>Scale</code> value, the color constants, and the buffer size math all express the same underlying concept: <strong>how pixels are packed into bytes</strong>. This concept appears in at least four places in a naive design (Image buffer, Display config, Color validation, driver registry). It should be modeled once.</p>

<p><code>PixelFormat</code> is a <code>Data.define(:name, :bits_per_pixel, :palette)</code> value object. <code>Palette</code> is an <code>Enumerable</code> color lookup table with nearest-color matching (memoized by packed RGBA key). Four format constants cover all vendor displays: <code>MONO</code>, <code>GRAY4</code>, <code>COLOR4</code>, <code>COLOR7</code>.</p>

<p>Both <code>Display</code> and <code>Framebuffer</code> reference a <code>PixelFormat</code>. The Display declares what format it requires. The Framebuffer declares what format it contains. Compatibility is checked once at the point of use (<code>display.show(framebuffer)</code>), not scattered across layers.</p>

<p><strong>Dual-buffer displays</strong> (black + red/yellow) are modeled as two Framebuffers, both <code>MONO</code> format, not as a special pixel format. The <code>Renderer</code> handles splitting a Canvas into the two mono Framebuffers via color-channel mapping. The <code>DualBuffer</code> capability module is purely a hardware concern â€” it knows how to send two buffers over SPI.</p>

<blockquote>
<p>See <a href="API_REFERENCE_md.html#1-core-value-types">API_REFERENCE.md, Section 1</a> for the full Palette and PixelFormat implementations.</p>
</blockquote>

<span id="label-3.2+Directory+Structure" class="legacy-anchor"></span>
<h3 id="32-directory-structure"><a href="#32-directory-structure">3.2 Directory Structure</a></h3>

<pre>ext/chroma_wave/                    # C -- only what MUST be C
  chroma_wave.c                       # Init_chroma_wave: define module, classes, constants
  chroma_wave.h                       # Shared type definitions, Ruby VALUE externs
  device.c                            # Device: SPI/GPIO lifecycle + shared I/O primitives
  |                                   #   epd_send_command(), epd_send_data(), epd_reset(),
  |                                   #   epd_read_busy() -- factored OUT of individual drivers
  framebuffer.c                       # Framebuffer: pixel packing (set_pixel, get_pixel,
  |                                   #   clear, raw buffer access). ~100 lines extracted
  |                                   #   from GUI_Paint.c. Parameterized, no global state.
  canvas.c                            # Canvas C accelerators: _canvas_clear, _canvas_blit_alpha,
  |                                   #   _canvas_load_rgba. ~80 lines. Operates on Canvas&#39;s
  |                                   #   packed String buffer via RSTRING_PTR. Optional â€”
  |                                   #   Ruby fallbacks exist for all three methods.
  display.c                           # Display: init/clear/refresh/sleep dispatch.
  |                                   #   Calls device I/O + driver-specific logic.
  driver_registry.c                   # Two-tier registry: config data + optional overrides.
  |                                   #   Generic init/display functions interpret config tables.
  |                                   #   Complex models provide override function pointers.
  freetype.c                          # FreeType bindings: load_face, render_glyph, metrics
  freetype.h                          # FT_Library lifecycle, FT_Face struct wrapper
  extconf.rb                          # Platform detection, backend selection, compiler flags
  |
  vendor/                             # Vendored C sources (restructured from vendor/waveshare_epd)
    config/                           #   DEV_Config.c, platform backends (as-is)
    drivers/                          #   All EPD_*.c files -- compiled unconditionally.
    |                                 #   Boilerplate (Reset/SendCommand/SendData/ReadBusy)
    |                                 #   is stripped; these files provide only Init register
    |                                 #   sequences, LUT tables, and model-specific Display
    |                                 #   logic for complex models.
    |                                 #   Root vendor/waveshare_epd/ kept as upstream reference.

lib/chroma_wave/                    # Ruby -- everything that doesn&#39;t need to be C
  chroma_wave.rb                      # Top-level require, autoloads
  version.rb                          # VERSION constant
  errors.rb                           # Exception hierarchy (Error, DeviceError, etc.)
  palette.rb                          # Palette value object (color lookup, nearest-match, indexing)
  pixel_format.rb                     # PixelFormat value object (MONO, GRAY4, COLOR7, etc.)
  color.rb                            # Color (RGBA Data.define, named constants, compositing)
  surface.rb                          # Surface protocol module (duck-type drawing target)
  framebuffer.rb                      # Ruby wrapper for C-backed Framebuffer (includes Surface)
  canvas.rb                           # RGB pixel buffer, compositing, drawing (includes Surface)
  layer.rb                            # Clipped, offset sub-region of a parent Surface
  renderer.rb                         # Canvasâ†’Framebuffer: quantization, dithering, channel split
  drawing/                            # Drawing primitives (mixed into Surface)
    primitives.rb                     #   line, polyline, rect, rounded_rect, circle,
    |                                 #   ellipse, arc, polygon, flood_fill
    text.rb                           #   draw_text, word_wrap, render_glyph
  font.rb                            # Font loading, measurement, glyph iteration (wraps C)
  icon_font.rb                       # IconFont (Font subclass, symbolâ†’codepoint registry)
  icon_font/
    lucide_glyphs.rb                  #   Generated glyph map (rake icons:generate)
  image.rb                           # Image loading via ruby-vips (load, resize, crop, blit)
  transform.rb                        # Rotation, mirroring, coordinate mapping
  device.rb                           # Hardware lifecycle, connection management, Mutex
  display.rb                          # Display factory (symbol registry), base methods
  registry.rb                         # Model registry: builds subclasses from C config data
  capabilities/                       # Composable capability modules (wrap private C methods)
    partial_refresh.rb                #   display_partial, display_base
    fast_refresh.rb                   #   init_fast, display_fast
    grayscale_mode.rb                 #   init_grayscale, display_grayscale
    dual_buffer.rb                    #   show(black_fb, red_fb) -- hardware SPI concern only
    regional_refresh.rb               #   display_region(fb, x, y, w, h)

data/
  fonts/
    lucide.ttf                        # Bundled icon font (~120KB, ISC license)
    LICENSE-lucide.txt                # Lucide license text</pre>

<span id="label-3.3+Model+Instantiation+and+the+Registry" class="legacy-anchor"></span>
<h3 id="33-model-instantiation-and-the-registry"><a href="#33-model-instantiation-and-the-registry">3.3 Model Instantiation and the Registry</a></h3>

<p>Users instantiate displays via a <strong>symbol registry</strong>. <code>Display.new</code> is a factory that returns an instance of a dynamically-constructed subclass with the correct capability modules:</p>

<pre class="ruby"><span class="ruby-identifier">display</span> = <span class="ruby-constant">ChromaWave</span><span class="ruby-operator">::</span><span class="ruby-constant">Display</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">model:</span> <span class="ruby-value">:epd_2in13_v4</span>)
<span class="ruby-identifier">display</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:display_partial</span>)          <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">display</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Capabilities</span><span class="ruby-operator">::</span><span class="ruby-constant">PartialRefresh</span>)    <span class="ruby-comment"># =&gt; true</span>

<span class="ruby-constant">ChromaWave</span><span class="ruby-operator">::</span><span class="ruby-constant">Display</span>.<span class="ruby-identifier">models</span>  <span class="ruby-comment"># =&gt; [:epd_2in13_v4, :epd_7in5_v2, ...]</span>
</pre>

<p>At gem load time, the registry iterates C-side model configs and builds one Ruby subclass per model, including the appropriate capability modules based on the configâ€™s capability bitfield. Typos raise <code>ModelNotFoundError</code> immediately with did-you-mean suggestions.</p>

<blockquote>
<p>See <a href="API_REFERENCE_md.html#34-model-registry">API_REFERENCE.md, Section 3.4</a> for the registry implementation.</p>
</blockquote>

<span id="label-3.4+Capabilities+as+Composable+Modules" class="legacy-anchor"></span>
<h3 id="34-capabilities-as-composable-modules"><a href="#34-capabilities-as-composable-modules">3.4 Capabilities as Composable Modules</a></h3>

<p>The vendor drivers expose capabilities as inconsistently-named optional functions (<code>Init_Fast</code>, <code>Display_Partial</code>, <code>Display_Part</code>, <code>Display_part</code>). Rather than modeling these as nullable function pointers in a flat C struct, use Ruby modules that wrap private C methods.</p>

<p>Five capability modules: <code>PartialRefresh</code>, <code>FastRefresh</code>, <code>GrayscaleMode</code>, <code>DualBuffer</code>, <code>RegionalRefresh</code>. Each provides a public Ruby API with format validation, delegating to private C methods (<code>_epd_display_partial</code>, <code>_epd_init_fast</code>, etc.) defined on the Display base class in <code>Init_chroma_wave</code>.</p>

<p>The base <code>Display#show</code> accepts either a Canvas (common path, auto-rendered) or a pre-rendered Framebuffer (power-user path). <code>DualBuffer</code> overrides <code>show</code> to split the Canvas into two mono Framebuffers via the Renderer.</p>

<p><strong>Advantages over nullable function pointers:</strong> - Shared behavior is defined once per capability, reused across all models that support it - <code>display.respond_to?(:display_partial)</code> works naturally for capability checking - <code>display.is_a?(Capabilities::FastRefresh)</code> for type-based dispatch - New capabilities are added without changing existing code (Open/Closed Principle) - Documentation and tests live with each capability module - C bridge is explicit: Ruby modules wrap private C methods with validation</p>

<blockquote>
<p>See <a href="API_REFERENCE_md.html#3-display--capabilities">API_REFERENCE.md, Section 3</a> for the full Display, C bridge, and capability module implementations.</p>
</blockquote>

<span id="label-3.5+Two-Tier+Driver+Registry" class="legacy-anchor"></span>
<h3 id="35-two-tier-driver-registry"><a href="#35-two-tier-driver-registry">3.5 Two-Tier Driver Registry</a></h3>

<p>Analysis of all 70 driver files reveals that <strong>60-70% of driver code is identical boilerplate</strong> (see <a href="WAVESHARE_LIBRARY_md.html#9-driver-variation-analysis">WAVESHARE_LIBRARY.md, Section 9</a>): <code>Reset()</code>, <code>SendCommand()</code>, <code>SendData()</code>, <code>ReadBusy()</code> are copy-pasted with only busy polarity and reset timing varying. What actually differs per model:</p>

<table role="table">
<thead>
<tr>
<th>Variation</th>
<th>Type</th>
<th>Can Be Config Data?</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resolution (w, h)</td>
<td>Data</td>
<td>Yes</td>
</tr>
<tr>
<td>Reset timings (ms)</td>
<td>Data</td>
<td>Yes â€“ <code>{20, 2, 20}</code> vs <code>{200, 2, 200}</code></td>
</tr>
<tr>
<td>Busy-wait polarity</td>
<td>Data</td>
<td>Yes â€“ <code>ACTIVE_HIGH</code> vs <code>ACTIVE_LOW</code></td>
</tr>
<tr>
<td>Init register sequence</td>
<td>Data</td>
<td>Yes â€“ encoded as <code>{cmd, len, data...}</code> pairs</td>
</tr>
<tr>
<td>Display write command</td>
<td>Data</td>
<td>Yes â€“ <code>0x24</code> vs <code>0x10</code></td>
</tr>
<tr>
<td>Pixel format</td>
<td>Data</td>
<td>Yes â€“ maps to <code>PixelFormat</code> enum</td>
</tr>
<tr>
<td>LUT waveform tables</td>
<td><strong>Code</strong></td>
<td>No â€“ Tier 2 overrides own their LUT data (see below)</td>
</tr>
<tr>
<td>Capability flags</td>
<td>Data</td>
<td>Yes â€“ bitmask</td>
</tr>
<tr>
<td>LUT selection logic</td>
<td><strong>Code</strong></td>
<td>No â€“ runtime mode selection (EPD_4in2, EPD_3in7)</td>
</tr>
<tr>
<td>4-gray pixel repacking</td>
<td><strong>Code</strong></td>
<td>No â€“ controller-specific bit manipulation</td>
</tr>
<tr>
<td>7-color power workflow</td>
<td><strong>Code</strong></td>
<td>No â€“ EPD_5in65f requires power on/off per refresh</td>
</tr>
<tr>
<td>In-place buffer invert</td>
<td><strong>Code</strong></td>
<td>No â€“ EPD_7in5_V2 inverts buffer before sending</td>
</tr>
</tbody>
</table>

<p>This motivates a <strong>two-tier registry</strong> in C:</p>
<ul><li>
<p><strong>Tier 1 (<code>epd_model_config_t</code>):</strong> Static configuration struct â€” resolution, pixel format, busy polarity, reset timing, init register sequence, display command, capability flags. Handles 60-70% of drivers completely with zero custom C code.</p>
</li><li>
<p><strong>Tier 2 (<code>epd_driver_t</code>):</strong> Optional code overrides â€” <code>custom_init</code>, <code>custom_display</code>, <code>pre_display</code>, <code>post_display</code> function pointers. Only ~20 models need these.</p>
</li></ul>

<p>A single <code>epd_generic_init()</code> function interprets <code>init_sequence</code> byte arrays. Simple monochrome displays need <strong>zero custom C code</strong> â€” just a config struct entry. Complex models provide override function pointers that call <code>epd_generic_init()</code> for the shared part and add their own logic (LUT selection, power cycling, buffer inversion, etc.).</p>

<p><strong>LUT tables are Tier 2 concerns.</strong> Override functions own their LUT data as <code>static const</code> byte arrays, keeping the Tier 1 config struct simple.</p>

<p><strong>Impact:</strong> Adding support for a new simple display model is adding ~10 lines of config data rather than writing a new C file.</p>

<blockquote>
<p>See <a href="API_REFERENCE_md.html#5-two-tier-driver-registry-c">API_REFERENCE.md, Section 5</a> for the C struct definitions and override examples.</p>
</blockquote>

<span id="label-3.6+Device+Owns+I-2FO+Primitives" class="legacy-anchor"></span>
<h3 id="36-device-owns-io-primitives"><a href="#36-device-owns-io-primitives">3.6 Device Owns I/O Primitives</a></h3>

<p>The vendor library duplicates <code>Reset()</code>, <code>SendCommand()</code>, <code>SendData()</code>, and <code>ReadBusy()</code> as static functions in every one of 70 driver files. These are identical except for busy-wait polarity and reset timing, both configurable via <code>epd_model_config_t</code>.</p>

<p>In our architecture, these live on the <strong>Device</strong> as shared functions parameterized by model config: <code>epd_reset()</code>, <code>epd_send_command()</code>, <code>epd_send_data()</code>, <code>epd_send_data_bulk()</code>, <code>epd_read_busy()</code>. This eliminates ~20 lines x 70 drivers = <strong>~1,400 lines of duplicated C code</strong> and centralizes the timeout/interruptibility improvement in one place.</p>

<span id="label-3.7+Three-Layer+Drawing+Architecture" class="legacy-anchor"></span>
<h3 id="37-three-layer-drawing-architecture"><a href="#37-three-layer-drawing-architecture">3.7 Three-Layer Drawing Architecture</a></h3>

<p>The vendorâ€™s <code>PAINT</code> struct conflates pixel storage, coordinate transforms, and drawing state into a single global. Our design separates these into three layers with distinct responsibilities:</p>

<pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ğŸ¨ Drawing Layer                       â”‚
â”‚                                                          â”‚
â”‚  Surface â† duck-type protocol (set_pixel, dimensions)   â”‚
â”‚    â”œâ”€â”€ Canvas        (RGBA packed String, C-accelerated) â”‚
â”‚    â”œâ”€â”€ Layer         (clipped sub-region of a Surface)   â”‚
â”‚    â””â”€â”€ Framebuffer   (device-format, C-backed)           â”‚
â”‚                                                          â”‚
â”‚  Drawing primitives work on any Surface:                 â”‚
â”‚    line, rect, circle, text, blit, flood_fill            â”‚
â”‚                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   ğŸ”„ Rendering Layer                     â”‚
â”‚                                                          â”‚
â”‚  Renderer: Canvas â†’ Framebuffer                          â”‚
â”‚    â€¢ Palette mapping (Color â†’ palette entry)              â”‚
â”‚    â€¢ Dithering (Floyd-Steinberg, ordered, threshold)     â”‚
â”‚    â€¢ Dual-buffer splitting (one Canvas â†’ two mono FBs)   â”‚
â”‚                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   âš¡ Hardware Layer                       â”‚
â”‚                                                          â”‚
â”‚  Framebuffer (C) â†’ Display (C) â†’ Device (C)              â”‚
â”‚    â€¢ Pixel packing, SPI transfer, GPIO lifecycle         â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>

<span id="label-Surface-3A+The+Drawing+Target+Protocol" class="legacy-anchor"></span>
<h4 id="surface-the-drawing-target-protocol"><a href="#surface-the-drawing-target-protocol">Surface: The Drawing Target Protocol</a></h4>

<p>Any object that includes <code>Surface</code> is a valid drawing target. The module requires three methods from includers (<code>set_pixel</code>, <code>get_pixel</code>, <code>width</code>/<code>height</code>) and provides drawing primitives as mixins. The same <code>draw_line</code> works on a Canvas (RGB), a Framebuffer (device format), or a Layer (clipped sub-region).</p>

<p><code>set_pixel</code> silently clips out-of-bounds writes. <code>get_pixel</code> returns <code>nil</code> for out-of-bounds reads. This asymmetry is intentional: silent clipping avoids overhead in the hot drawing path, while explicit <code>nil</code> prevents silent use of garbage data on reads.</p>

<span id="label-Canvas-3A+RGBA+Compositing+Surface" class="legacy-anchor"></span>
<h4 id="canvas-rgba-compositing-surface"><a href="#canvas-rgba-compositing-surface">Canvas: RGBA Compositing Surface</a></h4>

<p>Canvas stores pixels in a <strong>packed binary String</strong> (4 bytes/pixel: RGBA). This is a single GC object regardless of resolution. C accelerators (~80 lines in <code>canvas.c</code>) handle three hot paths that would otherwise require per-pixel Rubyâ†’C round-trips: <code>_canvas_clear</code>, <code>_canvas_blit_alpha</code>, <code>_canvas_load_rgba</code>. All three have Ruby fallbacks.</p>

<table role="table">
<thead>
<tr>
<th>Metric</th>
<th>Array&lt;Color&gt; (rejected)</th>
<th>Packed String (chosen)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Memory per 800Ã—480 Canvas</td>
<td>~15MB (384K Ã— ~40B)</td>
<td>~1.5MB (384K Ã— 4B)</td>
</tr>
<tr>
<td>GC objects per Canvas</td>
<td>~384,001</td>
<td>2 (Canvas + String)</td>
</tr>
<tr>
<td><code>Canvas.new</code> + clear</td>
<td>~120ms (384K Color.new)</td>
<td>&lt;1ms (String.new)</td>
</tr>
<tr>
<td><code>Image#draw_onto</code> 800Ã—480</td>
<td>~800ms (384K Color.new)</td>
<td>~5ms (C bulk memcpy)</td>
</tr>
<tr>
<td><code>blit</code> 400Ã—300 with alpha</td>
<td>~50ms (120K get/over/set)</td>
<td>~2ms (C alpha loop)</td>
</tr>
<tr>
<td>4 Layers on Pi Zero</td>
<td>~60MB, GC thrashing</td>
<td>~6MB, no GC pressure</td>
</tr>
</tbody>
</table>

<p><strong>Why an RGBA intermediate matters:</strong> If Canvas wrote directly to a Framebuffer, every <code>set_pixel</code> quantizes immediately â€” a photo blitted onto a mono surface loses all color information before text could be composited over it. With an RGBA Canvas, composition happens in full color and quantization is applied once at the end by the Renderer.</p>

<p><strong>Color materialization is lazy.</strong> <code>get_pixel</code> creates a <code>Color</code> on demand from 4 bytes. Bulk operations (image loading, blit, clear, quantization) operate directly on packed bytes, bypassing Color entirely. The Renderer iterates <code>canvas.rgba_bytes</code> in a single linear scan.</p>

<span id="label-Layer-3A+Clipped+Sub-Region" class="legacy-anchor"></span>
<h4 id="layer-clipped-sub-region"><a href="#layer-clipped-sub-region">Layer: Clipped Sub-Region</a></h4>

<p>A Layer wraps a parent Surface with an offset and clip rectangle. Drawing uses local coordinates (0,0 is top-left of the layer). Layers compose â€” a Layer of a Layer works correctly. This is the foundation for widget-based UI composition.</p>

<p>Layer bounds are <strong>not validated</strong> against the parent. Out-of-bounds coordinates delegate to the parentâ€™s clipping behavior. This avoids validation overhead and allows intentional â€œoverflowâ€ patterns.</p>

<span id="label-Renderer-3A+Canvas+-E2-86-92+Framebuffer+Bridge" class="legacy-anchor"></span>
<h4 id="renderer-canvas--framebuffer-bridge"><a href="#renderer-canvas--framebuffer-bridge">Renderer: Canvas â†’ Framebuffer Bridge</a></h4>

<p>The Renderer owns <strong>quantization</strong> â€” converting RGBA Canvas pixels to palette entries in a device-format Framebuffer. This is the only place where dithering algorithms are applied (Floyd-Steinberg default, ordered for text, threshold for line art). Dual-buffer channel splitting also lives here â€” the <code>DualBuffer</code> capability module is hardware-only (SPI send); the Renderer handles the logical concern of routing colors to two mono layers.</p>

<span id="label-Framebuffer-3A+Device-Format+Pixel+Storage" class="legacy-anchor"></span>
<h4 id="framebuffer-device-format-pixel-storage"><a href="#framebuffer-device-format-pixel-storage">Framebuffer: Device-Format Pixel Storage</a></h4>

<p>C-backed pixel buffer in the displayâ€™s native format. Includes <code>Surface</code> so it can be drawn on directly (power-user path). <code>set_pixel</code> accepts palette entry symbols (<code>:black</code>, <code>:red</code>); the C implementation maps to integer indices and bit-packs. The <code>Surface</code> protocol is duck-typed â€” it passes color values through without constraining the type.</p>

<span id="label-Transform+Integration" class="legacy-anchor"></span>
<h4 id="transform-integration"><a href="#transform-integration">Transform Integration</a></h4>

<p>Coordinate transforms (rotation, mirroring) apply at the <code>Surface</code> level via a <code>Transform</code> value object composed with a <code>TransformedSurface</code> wrapper. Canvas always operates in logical (unrotated) coordinates â€” physical rotation is applied at the Rendererâ†’Framebuffer boundary.</p>

<blockquote>
<p><strong>Deferred design:</strong> The concrete Transform API will be designed during implementation.</p>

<p>See <a href="API_REFERENCE_md.html#2-surface-protocol--implementations">API_REFERENCE.md, Sections 2-4</a> for full Surface, Canvas, Layer, Framebuffer, and Renderer implementations.</p>
</blockquote>
<hr>

<span id="label-4.+Content+Pipeline" class="legacy-anchor"></span>
<h2 id="4-content-pipeline"><a href="#4-content-pipeline">4. Content Pipeline</a></h2>

<p>The content that flows through the drawing layers â€” colors, shapes, text, icons, and images â€”is specified in a dedicated document.</p>

<blockquote>
<p>See <a href="CONTENT_PIPELINE_md.html">CONTENT_PIPELINE.md</a> for the complete content pipeline spec.</p>
</blockquote>

<p><strong>Summary:</strong> Colors are RGBA <code>Data.define</code> value objects with alpha compositing. Drawing primitives (Bresenham, midpoint circle, scanline fill) are <code>Surface</code> mixins. Text rendering uses FreeType (C-linked) for glyph rasterization with Ruby-side layout. Icons use an <code>IconFont</code> class with bundled Lucide (~1,500 icons, ISC license). Images load via ruby-vips with bulk RGBA transfer into Canvas.</p>
<hr>

<span id="label-5.+Integration+Challenges" class="legacy-anchor"></span>
<h2 id="5-integration-challenges"><a href="#5-integration-challenges">5. Integration Challenges</a></h2>

<span id="label-5.1+Platform+Detection+in+extconf.rb" class="legacy-anchor"></span>
<h3 id="51-platform-detection-in-extconfrb"><a href="#51-platform-detection-in-extconfrb">5.1 Platform Detection in <a href="../ext/chroma_wave/extconf_rb.html">extconf.rb</a></a></h3>

<p>Need to: - Check for <code>lgpio.h</code>, <code>bcm2835.h</code>, <code>wiringPi.h</code>, <code>gpiod.h</code> headers - Check for corresponding <code>-l</code> libraries - Auto-select the best available backend - Provide a <code>--with-epd-backend=</code> configure option for override - Define a <code>MOCK</code> backend for development/testing on non-RPi systems</p>

<p><strong>Fallback behavior:</strong> If no GPIO/SPI library is found, <a href="../ext/chroma_wave/extconf_rb.html">extconf.rb</a> <strong>auto-selects the MOCK backend</strong> and emits a warning. The gem always installs. Under MOCK, <code>Framebuffer</code>, <code>Canvas</code>, <code>PixelFormat</code>, and all drawing operations work normally (pure memory, no hardware). Hardware operations (<code>Display#show</code>, <code>Display#clear</code>, <code>Device.new</code>) raise <a href="../../classes/ChromaWave/DeviceError.html"><code>ChromaWave::DeviceError</code></a> at runtime with a clear message.</p>

<p><strong>FreeType is optional.</strong> If not found, the extension compiles without <code>freetype.c</code> and sets <code>-DNO_FREETYPE</code>. At runtime, <code>Font.new</code>, <code>IconFont.new</code>, and <code>Surface#draw_text</code> raise <a href="../../classes/ChromaWave/DependencyError.html"><code>ChromaWave::DependencyError</code></a> with an install hint (<code>apt install libfreetype-dev</code>).</p>

<span id="label-5.2+Buffer+Ownership+and+GC+Integration" class="legacy-anchor"></span>
<h3 id="52-buffer-ownership-and-gc-integration"><a href="#52-buffer-ownership-and-gc-integration">5.2 Buffer Ownership and GC Integration</a></h3>

<p>Framebuffers own pixel data allocated via <code>xmalloc</code>/<code>xfree</code> (Rubyâ€™s tracked allocator). Wrapped with <code>TypedData_Wrap_Struct</code> with: - <code>dfree</code>: calls <code>xfree</code> on the pixel buffer - <code>dsize</code>: reports <code>buffer_size</code> bytes to Rubyâ€™s GC for memory pressure tracking - <code>dmark</code>: not needed (no <code>VALUE</code>s stored in the C struct) - <code>flags</code>: <code>RUBY_TYPED_FREE_IMMEDIATELY</code> (no GVL needed for <code>xfree</code>)</p>

<span id="label-5.3+Busy-Wait+Blocking+and+GVL+Release" class="legacy-anchor"></span>
<h3 id="53-busy-wait-blocking-and-gvl-release"><a href="#53-busy-wait-blocking-and-gvl-release">5.3 Busy-Wait Blocking and GVL Release</a></h3>

<p><code>EPD_*_ReadBusy()</code> spin-waits with no timeout. This blocks the GVL. Our design: - Wrap display refresh operations with <code>rb_thread_call_without_gvl()</code> so other Ruby threads can run during the (potentially multi-second) refresh cycle - Add a configurable timeout with an interruptible loop (10ms polling interval) - Provide an unblocking function (<code>ubf</code>) for clean interrupt of long refreshes</p>

<span id="label-5.4+EPD_7in5_V2+Destructive+Buffer+Inversion" class="legacy-anchor"></span>
<h3 id="54-epd7in5v2-destructive-buffer-inversion"><a href="#54-epd7in5v2-destructive-buffer-inversion">5.4 EPD_7in5_V2 Destructive Buffer Inversion</a></h3>

<p><code>EPD_7IN5_V2_Display()</code> modifies the callerâ€™s buffer in-place (bitwise NOT) before sending over SPI. This is a bug in the vendor code. <strong>Resolution:</strong> Copy the buffer before passing to the driver. The copy cost is negligible (800x480/8 = 48KB, microseconds to copy).</p>

<span id="label-5.5+EPD_5in65f+Dual+Busy+Polarity" class="legacy-anchor"></span>
<h3 id="55-epd5in65f-dual-busy-polarity"><a href="#55-epd5in65f-dual-busy-polarity">5.5 EPD_5in65f Dual Busy Polarity</a></h3>

<p><code>EPD_5in65f</code> uses both busy-HIGH and busy-LOW waits in different lifecycle phases. <strong>Resolution:</strong> This model already requires a Tier 2 override for its power-on/off-per-refresh cycle. The override owns its busy-wait logic entirely, calling polarity-specific helpers internally. No change to the Tier 1 config struct is needed.</p>

<span id="label-5.6+Error+Handling+Strategy" class="legacy-anchor"></span>
<h3 id="56-error-handling-strategy"><a href="#56-error-handling-strategy">5.6 Error Handling Strategy</a></h3>

<p>A <strong>categorized exception hierarchy</strong> separates hardware errors (inherit from <code>ChromaWave::Error &lt; StandardError</code>) from API misuse errors (inherit from <code>ArgumentError</code> / <code>TypeError</code>). C functions return <code>int</code> status codes; Ruby wrappers check and raise the appropriate exception.</p>

<blockquote>
<p>See <a href="API_REFERENCE_md.html#6-error-hierarchy">API_REFERENCE.md, Section 6</a> for the full hierarchy.</p>
</blockquote>

<span id="label-5.7+Thread+Safety" class="legacy-anchor"></span>
<h3 id="57-thread-safety"><a href="#57-thread-safety">5.7 Thread Safety</a></h3>

<p>Device-level mutual exclusion via a Ruby <code>Mutex</code>. All hardware operations synchronize through the Deviceâ€™s mutex. Pure-memory operations (<code>Framebuffer#set_pixel</code>, Canvas drawing) are <strong>not locked</strong> â€” contention is the callerâ€™s responsibility.</p>

<p>The GVL release composes correctly: mutex acquired before entering C, GVL released inside C for busy-wait, mutex released after C returns. Other Ruby threads can run during busy-wait but cannot start a concurrent hardware operation.</p>

<span id="label-5.8+Multi-Display+-28Out+of+Scope+for+v1-29" class="legacy-anchor"></span>
<h3 id="58-multi-display-out-of-scope-for-v1"><a href="#58-multi-display-out-of-scope-for-v1">5.8 Multi-Display (Out of Scope for v1)</a></h3>

<p>Multiple displays on one Raspberry Pi are architecturally possible â€” the SPI bus is shared while each display needs its own CS, DC, RST, and BUSY GPIO pins. However, the vendor HAL hardcodes pin assignments as global integers and supports only one active display. Supporting multi-display would require reworking the HAL to accept per-display pin configuration. This is deferred to a future version â€” v1 supports one Display per Device (1:1).</p>
<hr>

<span id="label-6.+Expected+C+Footprint" class="legacy-anchor"></span>
<h2 id="6-expected-c-footprint"><a href="#6-expected-c-footprint">6. Expected C Footprint</a></h2>

<table role="table">
<thead>
<tr>
<th>Component</th>
<th>Vendor Lines</th>
<th>After Refactor</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEV_Config + backends</td>
<td>~1,200</td>
<td>~1,200</td>
<td>Used as-is</td>
</tr>
<tr>
<td>EPD_*.c drivers</td>
<td>~25,000</td>
<td>~8,000</td>
<td>Data tables + ~20 custom files</td>
</tr>
<tr>
<td>GUI_Paint + BMPfile</td>
<td>~1,200</td>
<td>~100</td>
<td>Pixel packing only</td>
</tr>
<tr>
<td>Fonts</td>
<td>~15,000</td>
<td>0</td>
<td>Not vendored</td>
</tr>
<tr>
<td>Canvas accelerators</td>
<td>0</td>
<td>~80</td>
<td>New: clear, blit_alpha, load_rgba</td>
</tr>
<tr>
<td>FreeType bindings</td>
<td>0</td>
<td>~200</td>
<td>New: glyph rasterization bridge</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td><strong>~42,400</strong></td>
<td><strong>~9,580</strong></td>
<td><strong>23% of original</strong></td>
</tr>
</tbody>
</table>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna"><strong>Hanna</strong> RDoc template</a>
</div>
</body>
</html>
